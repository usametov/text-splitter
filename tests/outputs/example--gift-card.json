[{"chunk":"import { Callout } from \"nextra-theme-docs\";\n\n# Gift Card\n\nLet's build a UI to send and redeem a gift card using smart contracts on Cardano.\n\n<Callout type=\"info\">\nYou can find code supporting this tutorial on [Aiken's main repository](https://github.com/aiken-lang/aiken/tree/main/examples/gift_card).\n</Callout>\n\n## Covered in this tutorial\n\n<br/>\n\n- [x] Writing `Aiken` inter-dependent `mint` & `spend` validators.\n- [x] Parameterizing validators.\n- [x] Using [Lucid](https://lucid.spacebudz.io/) with [Blockfrost](https://blockfrost.io)<sup>â˜…</sup>.\n  <sub>\n    â˜… We'll once again be using the `Blockfrost` provider. So have your Blockfrost API key ready.\n  </sub>\n- [x] Using [Deno fresh](https://fresh.deno.dev/)<sup>â˜…</sup>.\n  <sub>\n  â˜… You can install deno using these [instructions](https://deno.land/manual@v1.29.1/getting_started/installation).\n  </sub>\n\n<Callout type=\"info\" emoji=\"ðŸ“˜\">\n  When encountering an unfamiliar syntax or concept, do not hesitate to refer to\n  the [language-tour](/language-tour) for details and extra examples.\n</Callout>\n\n## What is a gift card?\n\nIn the context of this tutorial a gift card will involve locking some assets\nin a smart contract. While some assets are being locked, we'll mint an NFT in\nthe same transaction. This NFT could be sent anywhere and the owner of the NFT\ncan burn it to unlock the assets that were previously locked. We can think of\nthe NFT as a gift card.","seq_id":0,"src":"tests/inputs/example--gift-card.mdx"},{"chunk":"## Aiken is the easy part\n\nLet's go ahead and create a new `Aiken` project:\n\n```sh\naiken new my-org/gift-card\ncd gift-card\n```\n\n<Callout type=\"info\">\n  `my-org` above can be replaced by any name. We recommend using the name of a\n  Github organization or your own username.\n</Callout>\n\nWe've already covered what `aiken new` generates in a previous tutorial so\nlet's jump right into some code.\n\nGo ahead and remove the `lib/` folder, we won't be needing that for this tutorial.\n\n```\nrm -rf lib\n```\n\nNow let's create a new file in the `validators/` folder called `oneshot.ak`.\n\n```\ntouch validators/oneshot.ak\n```\n\n<Callout type=\"info\">\n  `oneshot.ak` could be named anything. Any file in `validators/` is allowed to\n  export as many validators as you'd like.\n</Callout>\n\nNow let's open the project folder in our favorite editor and define two empty\nvalidator functions.\n\n```aiken filename=\"validators/oneshot.ak\"\nuse aiken/transaction.{ScriptContext}\n\nvalidator {\n  fn gift_card(rdmr, ctx: ScriptContext) -> Bool {\n    todo @\"mint and burn\"\n  }\n}\n\nvalidator {\n  fn redeem(_d: Data, _r: Data, ctx: ScriptContext) -> Bool {\n    todo @\"redeem\"\n  }\n}\n```\n\nThe `gift_card` validator will be used to mint and burn the gift card NFT. The\n`redeem` validator will be used with `gift_card` to redeem the gift card and unlock the assets.\nThe life cycle of this gift card will involve two transactions. The first transaction\nwill mint the gift card as an NFT and it will send some assets to the `redeem` validator's address.\nThe gift card can be sent anywhere in the first transaction. The second transaction will\nburn the NFT and send the locked assets to the address that held the burned NFT.","seq_id":1,"src":"tests/inputs/example--gift-card.mdx"},{"chunk":"### Minting a Gift Card\n\nSince this example is for a oneshot minting contract let's add\nsome parameters to the validator that we can use to guarantee uniqueness.\n\n```aiken filename=\"validators/oneshot.ak\" /OutputReference/\nuse aiken/transaction.{OutputReference, ScriptContext}\n\nvalidator(token_name: ByteArray, utxo_ref: OutputReference) {\n  fn gift_card(rdmr, ctx: ScriptContext) -> Bool {\n    todo @\"mint and burn\"\n  }\n}\n```\n\nWe'll use the `utxo_ref` parameter to ensure this validator will only allow a mint once. Since\nthe Cardano ledger guarantees that utxos can only be spent once, we can leverage them to inherit\nsimilar guarantees in our validator.\n\nNext let's define a type for `rdmr`. We have two actions that this validator\nwill perform. This validator can be used to mint and then burn an NFT.\n\n```aiken filename=\"validators/oneshot.ak\" {3-6,10-15} /Action/2\nuse aiken/transaction.{OutputReference, ScriptContext}\n\ntype Action {\n  Mint\n  Burn\n}\n\nvalidator(token_name: ByteArray, utxo_ref: OutputReference) {\n  fn gift_card(rdmr: Action, ctx: ScriptContext) -> Bool {\n    when rdmr is {\n      Mint ->\n        todo @\"mint\"\n      Burn ->\n        todo @\"burn\"\n    }\n  }\n}\n```","seq_id":2,"src":"tests/inputs/example--gift-card.mdx"},{"chunk":"Next we'll do these things in order so that we have everything we need\nto perform the final check.\n\n- pattern match on the script context to get `transaction` and `purpose`\n- `expect` the `purpose` to be `tx.Mint(policy_id)`\n- pattern match on the `transaction` to get it's `inputs` and `mint` which holds minted assets\n- `expect` minted assets (`mint`) to only have one item which has an `asset_name` and an `amount`\n\n```aiken filename=\"validators/oneshot.ak\" {1,3,12-22} /Transaction/1\nuse aiken/dict\nuse aiken/transaction.{OutputReference, ScriptContext, Transaction} as tx\nuse aiken/transaction/value\n\ntype Action {\n  Mint\n  Burn\n}\n\nvalidator(token_name: ByteArray, utxo_ref: OutputReference) {\n  fn gift_card(rdmr: Action, ctx: ScriptContext) -> Bool {\n    let ScriptContext { transaction, purpose } = ctx\n\n    expect tx.Mint(policy_id) = purpose\n\n    let Transaction { inputs, mint, .. } = transaction\n\n    expect [(asset_name, amount)] =\n      mint\n        |> value.from_minted_value\n        |> value.tokens(policy_id)\n        |> dict.to_list()\n\n    when rdmr is {\n      Mint ->\n        todo @\"mint\"\n      Burn ->\n        todo @\"burn\"\n    }\n  }\n}\n```\n\nAt this point we have all the data we need to perform the final check for the `Mint` action.\nFor this validator to succeed we need to ensure that the `utxo_ref` parameter equals one of\nthe `inputs` in the transaction. In addition to this, we need to ensure `amount` is equal to one because\nwe're minting an NFT. For fun, we'll check that `asset_name` is equal to `token_name` from the parameters.","seq_id":3,"src":"tests/inputs/example--gift-card.mdx"},{"chunk":"```aiken filename=\"validators/oneshot.ak\" {2,26-30}\nuse aiken/dict\nuse aiken/list\nuse aiken/transaction.{OutputReference, ScriptContext, Transaction} as tx\nuse aiken/transaction/value\n\ntype Action {\n  Mint\n  Burn\n}\n\nvalidator(token_name: ByteArray, utxo_ref: OutputReference) {\n  fn gift_card(rdmr: Action, ctx: ScriptContext) -> Bool {\n    let ScriptContext { transaction, purpose } = ctx\n\n    expect tx.Mint(policy_id) = purpose\n\n    let Transaction { inputs, mint, .. } = transaction\n\n    expect [(asset_name, amount)] =\n      mint\n        |> value.from_minted_value\n        |> value.tokens(policy_id)\n        |> dict.to_list()\n\n    when rdmr is {\n      Mint -> {\n        expect True =\n          list.any(inputs, fn(input) { input.output_reference == utxo_ref })\n        amount == 1 && asset_name == token_name\n      }\n      Burn ->\n        todo @\"burn\"\n    }\n  }\n}\n```\n\nWe have everything we need in this validator to mint a Gift Card. Before\nwe start making transactions though, we'll need to finish the `Burn` action and that\nwill also be paired with the `redeem` validator.\n\n### Redeeming a Gift Card\n\nTo redeem a gift card we'll want a transaction that\nuses two validators. We'll use the `gift_card` validator with\nthe `Burn` action to burn the NFT. We'll also use the `redeem` validator\nto unlock the assets at that address.","seq_id":4,"src":"tests/inputs/example--gift-card.mdx"},{"chunk":"Let's finish the `Burn` action of the `gift_card` validator. We just need\nto check that `amount` is equal to negative one and that `asset_name` is equal to `token_name`.\n\n```aiken filename=\"validators/oneshot.ak\" {32}\nuse aiken/dict\nuse aiken/list\nuse aiken/transaction.{OutputReference, ScriptContext, Transaction} as tx\nuse aiken/transaction/value\n\ntype Action {\n  Mint\n  Burn\n}\n\nvalidator(token_name: ByteArray, utxo_ref: OutputReference) {\n  fn gift_card(rdmr: Action, ctx: ScriptContext) -> Bool {\n    let ScriptContext { transaction, purpose } = ctx\n\n    expect tx.Mint(policy_id) = purpose\n\n    let Transaction { inputs, mint, .. } = transaction\n\n    expect [(asset_name, amount)] =\n      mint\n        |> value.from_minted_value\n        |> value.tokens(policy_id)\n        |> dict.to_list()\n\n    when rdmr is {\n      Mint -> {\n        expect Some(_input) =\n          list.find(inputs, fn(input) { input.output_reference == utxo_ref })\n        amount == 1 && asset_name == token_name\n      }\n      Burn ->\n        amount == -1 && asset_name == token_name\n    }\n  }\n}\n```\n\nNow we can start working on the `redeem` validator. We'll want to parameterize this validator\nwith `token_name` and the `policy_id` which is the hash of the `gift_card` validator after having it's\nparams applied. We parameterize `redeem` with `gift_card`'s `policy_id` so that we can only use `redeem`\nexclusively with `gift_card`.","seq_id":5,"src":"tests/inputs/example--gift-card.mdx"},{"chunk":"```aiken filename=\"validators/oneshot.ak\" {8}\nuse aiken/dict\nuse aiken/list\nuse aiken/transaction.{OutputReference, ScriptContext, Transaction} as tx\nuse aiken/transaction/value\n\n// ... gift card validator ...\n\nvalidator(token_name: ByteArray, policy_id: ByteArray) {\n  fn redeem(_d: Data, _r: Data, ctx: ScriptContext) -> Bool {\n    todo @\"redeem\"\n  }\n}\n```\n\nLet's add some boilerplate to this validator so that we can get the\n`asset_name` and the `amount` out of the script context's transaction.\n\n```aiken filename=\"validators/oneshot.ak\" {10-18}\nuse aiken/dict\nuse aiken/list\nuse aiken/transaction.{OutputReference, ScriptContext, Transaction} as tx\nuse aiken/transaction/value\n\n// ... gift card validator ...\n\nvalidator(token_name: ByteArray, policy_id: ByteArray) {\n  fn redeem(_d: Data, _r: Data, ctx: ScriptContext) -> Bool {\n    let ScriptContext { transaction, .. } = ctx\n\n    let Transaction { mint, .. } = transaction\n\n    expect [(asset_name, amount)] =\n      mint\n        |> value.from_minted_value\n        |> value.tokens(policy_id)\n        |> dict.to_list()","seq_id":6,"src":"tests/inputs/example--gift-card.mdx"},{"chunk":"todo @\"redeem\"\n  }\n}\n```\n\nFinally we need to confirm that `asset_name` is equal to `token_name`\nand that `amount` is equal to negative one.\n\n```aiken filename=\"validators/oneshot.ak\" {20}\nuse aiken/dict\nuse aiken/list\nuse aiken/transaction.{OutputReference, ScriptContext, Transaction} as tx\nuse aiken/transaction/value\n\n// ... gift card validator ...\n\nvalidator(token_name: ByteArray, policy_id: ByteArray) {\n  fn redeem(_d: Data, _r: Data, ctx: ScriptContext) -> Bool {\n    let ScriptContext { transaction, .. } = ctx\n\n    let Transaction { mint, .. } = transaction\n\n    expect [(asset_name, amount)] =\n      mint\n        |> value.from_minted_value\n        |> value.tokens(policy_id)\n        |> dict.to_list()\n\n    amount == -1 && asset_name == token_name\n  }\n}\n```\n\nWe should make sure this builds. You've been running `aiken check` along the way right?!?\n\n<Callout type=\"info\">\n  Jokes aside, you're probably using an editor integration. If the editor\n  integration isn't giving you proper feed back or giving you a hard time please\n  come talk to us so we can make things better.\n</Callout>\n\n```sh\naiken build\n```\n\n## Building a frontend\n\nWith the easy part out of the way we can start building a frontend to interact with our\nsmart contracts in the browser. Deno fresh is an interesting project for building\nweb applications in Deno.","seq_id":7,"src":"tests/inputs/example--gift-card.mdx"},{"chunk":"### Setting up\n\nLet's generate a Deno fresh project in the same directory as our Aiken project.\n\n```sh\ndeno run -A -r https://fresh.deno.dev .\n```\n\n<Callout type=\"warning\">When prompted to enable Tailwind CSS say yes.</Callout>\n\nWe need lucid and we should probably add an alias for better looking imports.\nLet's edit `import_map.json`.\n\n```json filename=\"import_map.json\" {11-12}\n{\n  \"imports\": {\n    \"$fresh/\": \"...\",\n    \"preact\": \"...\",\n    \"preact/\": \"...\",\n    \"preact-render-to-string\": \"...\",\n    \"@preact/signals\": \"...\",\n    \"@preact/signals-core\": \"...\",\n    \"twind\": \"...\",\n    \"twind/\": \"...\",\n    \"lucid/\": \"https://deno.land/x/lucid@0.9.5/\",\n    \"~/\": \"./\"\n  }\n}\n```\n\nWe can delete a few things that come with the starter template that we don't need.\n\n```sh\nrm islands/Counter.tsx\nrm -rf routes/api\nrm routes/\\[name\\].tsx\n```\n\nLet's also add some reusable components to our project.\n\n```tsx filename=\"components/Button.tsx\"\nimport { JSX } from \"preact\";\nimport { IS_BROWSER } from \"$fresh/runtime.ts\";","seq_id":8,"src":"tests/inputs/example--gift-card.mdx"},{"chunk":"export function Button(props: JSX.HTMLAttributes<HTMLButtonElement>) {\n  return (\n    <button\n      {...props}\n      disabled={!IS_BROWSER || props.disabled}\n      class={`group inline-flex items-center justify-center rounded-full py-2 px-4 text-sm font-semibold focus:outline-none bg-blue-600 text-white hover:bg-blue-500 active:bg-blue-800 active:text-blue-100 ${props.class}`}\n    />\n  );\n}\n```\n\n<Callout type=\"info\">\n  You can just replace the existing Button component with the above code\n</Callout>\n\n```tsx filename=\"components/Input.tsx\"\nimport { ComponentChild, JSX } from \"preact\";\n\nexport function Input({\n  children,\n  id,\n  ...props\n}: JSX.HTMLAttributes<HTMLInputElement>) {\n  return (\n    <div>\n      <label for={id} class=\"block mb-3 text-sm font-medium text-gray-700\">\n        {children}\n      </label>\n      <input\n        {...props}\n        id={id}\n        class=\"block w-full appearance-none rounded-md border border-gray-200 bg-gray-50 px-3 py-2 text-gray-900 placeholder-gray-400 focus:border-blue-500 focus:bg-white focus:outline-none focus:ring-blue-500 sm:text-sm\"\n      />\n    </div>\n  );\n}\n```","seq_id":9,"src":"tests/inputs/example--gift-card.mdx"},{"chunk":"### Home page\n\nEverything we'll be doing with validators and transactions will happen fully client side.\nThis means we can just have our route render a single `island` component and then\nwe can write all of our code in this island for the most part.\n\nLet's create a new file `islands/Oneshot.tsx` and add the following code.\n\n```tsx filename=\"islands/Oneshot.tsx\"\nexport default function Oneshot() {\n  return <div>Oneshot</div>;\n}\n```\n\nNow inside of `routes/index.tsx` we can import our new island and render it.\n\n```tsx filename=\"routes/index.tsx\" {3,29}\nimport { Head } from \"$fresh/runtime.ts\";\n\nimport Oneshot from \"~/islands/Oneshot\";\n\nexport default function Home() {\n  return (\n    <>\n      <Head>\n        <title>One Shot</title>\n      </Head>\n\n      <div class=\"max-w-2xl mx-auto mt-20 mb-10\">\n        <div class=\"mb-10\">\n          <h2 class=\"text-lg font-semibold text-gray-900\">\n            Make a one shot minting and lock contract\n          </h2>\n\n          <h3 class=\"mt-4 mb-2\">Redeem</h3>\n          <pre class=\"bg-gray-200 p-2 rounded overflow-x-scroll\">\n            TODO: Render non-parameterized redeem validator\n          </pre>\n\n          <h3 class=\"mt-4 mb-2\">Gift Card</h3>\n          <pre class=\"bg-gray-200 p-2 rounded overflow-x-scroll\">\n            TODO: Render non-parameterized gift_card validator\n          </pre>\n        </div>","seq_id":10,"src":"tests/inputs/example--gift-card.mdx"},{"chunk":"<Oneshot />\n      </div>\n    </>\n  );\n}\n```\n\nYou can replace everything that was in `routes/index.tsx` with the above code.\nWe've left some `TODO`'s in the code to remind us to render the validators. We'll render\nthe compiled aiken code as a hex encoded string. There not much of a reason to do this, it's just\nkinda cool to see.\n\nNext we should load the `plutus.json` file and get the compiled aiken code. Let's create\na file called `utils.ts` and add the following code.\n\n```ts filename=\"utils.ts\"\nimport { MintingPolicy, SpendingValidator } from \"lucid/mod.ts\";\n\nimport blueprint from \"~/plutus.json\" assert { type: \"json\" };\n\nexport type Validators = {\n  redeem: SpendingValidator;\n  giftCard: MintingPolicy;\n};\n\nexport function readValidators(): Validators {\n  const redeem = blueprint.validators.find((v) => v.title === \"oneshot.redeem\");\n\n  if (!redeem) {\n    throw new Error(\"Redeem validator not found\");\n  }\n\n  const giftCard = blueprint.validators.find(\n    (v) => v.title === \"oneshot.gift_card\"\n  );\n\n  if (!giftCard) {\n    throw new Error(\"Gift Card validator not found\");\n  }\n\n  return {\n    redeem: {\n      type: \"PlutusV2\",\n      script: redeem.compiledCode,\n    },\n    giftCard: {\n      type: \"PlutusV2\",\n      script: giftCard.compiledCode,\n    },\n  };\n}\n```","seq_id":11,"src":"tests/inputs/example--gift-card.mdx"},{"chunk":"There's nothing particularly special here. We're just reading the `plutus.json` file\nand finding the compiled code for the `redeem` and `gift_card` validators. We're also\nexporting a type for the validators so we can use it in our island later. Having this function\npotentially throw an error is just a way to signal to us that we've done something wrong.\n\nLet's import our new `readValidators` file into our `routes/index.tsx` file and use it to\nin a server side handler. This will allow us to access the data in the `Home` page component\nas page props which we'll then use to render the validator's compiled code.\n\n```tsx filename=\"routes/index.tsx\" {2,5,7-9,11-17} /validators/4-8 /PageProps<Data>/ /data/\nimport { Head } from \"$fresh/runtime.ts\";\nimport { Handlers, PageProps } from \"$fresh/server.ts\";\n\nimport Oneshot from \"~/islands/Oneshot\";\nimport { readValidators, Validators } from \"~/utils.ts\";\n\ninterface Data {\n  validators: Validators;\n}\n\nexport const handler: Handlers<Data> = {\n  GET(_req, ctx) {\n    const validators = readValidators();\n\n    return ctx.render({ validators });\n  },\n};\n\nexport default function Home({ data }: PageProps<Data>) {\n  const { validators } = data;\n\n  return (\n    <>\n      <Head>\n        <title>One Shot</title>\n      </Head>\n\n      <div class=\"max-w-2xl mx-auto mt-20 mb-10\">\n        <div class=\"mb-10\">\n          <h2 class=\"text-lg font-semibold text-gray-900\">\n            Make a one shot minting and lock contract\n          </h2>","seq_id":12,"src":"tests/inputs/example--gift-card.mdx"},{"chunk":"<h3 class=\"mt-4 mb-2\">Redeem</h3>\n          <pre class=\"bg-gray-200 p-2 rounded overflow-x-scroll\">\n            {validators.redeem.script}\n          </pre>\n\n          <h3 class=\"mt-4 mb-2\">Gift Card</h3>\n          <pre class=\"bg-gray-200 p-2 rounded overflow-x-scroll\">\n            {validators.giftCard.script}\n          </pre>\n        </div>\n\n        <Oneshot validators={validators} />\n      </div>\n    </>\n  );\n}\n```\n\nYour editor will probably complain and say that `Oneshot` doesn't accept a `validators` prop.\nWe'll fix that in a moment.\n\n### The island\n\nIt's about time we start the real party and we've made it to the juicy part. In this island\nwe'll capture some user input, apply some params to our raw validators, and execute some transactions.\nTo keep things simple we'll assume [eternl](https://eternl.io/) is setup in your browser. Another thing\nwe'll do to keep things simple is have the gift card be sent to ourselves when minted. This way we\ncan test the redeeming of the gift card without having to send it to someone else or using a second wallet.\n\n#### Token name\n\nWe should give `Oneshot`'s props a type and capture the `token_name` so we can use it to\napply some params to the raw validators. Lucid also requires initialization so let's get\nsome boilerplate out of the way.\n\n```tsx filename=\"islands/Oneshot.tsx\"\nimport { useEffect, useState } from \"preact/hooks\";\nimport { Blockfrost, Lucid } from \"lucid/mod.ts\";","seq_id":13,"src":"tests/inputs/example--gift-card.mdx"},{"chunk":"import { Input } from \"~/components/Input.tsx\";\nimport { Button } from \"~/components/Button.tsx\";\nimport { Validators } from \"~/utils.ts\";\n\nexport interface OneshotProps {\n  validators: Validators;\n}\n\nexport default function Oneshot({ validators }: OneshotProps) {\n  const [lucid, setLucid] = useState<Lucid | null>(null);\n  const [blockfrostAPIKey, setBlockfrostAPIKey] = useState<string>(\"\");\n  const [tokenName, setTokenName] = useState<string>(\"\");\n\n  const setupLucid = async (e: Event) => {\n    e.preventDefault();\n\n    const lucid = await Lucid.new(\n      new Blockfrost(\n        \"https://cardano-preprod.blockfrost.io/api/v0\",\n        blockfrostAPIKey\n      ),\n      \"Preprod\"\n    );\n\n    setLucid(lucid);\n  };\n\n  useEffect(() => {\n    if (lucid) {\n      window.cardano.eternl.enable().then((wallet) => {\n        lucid.selectWallet(wallet);\n      });\n    }\n  }, [lucid]);\n\n  const submitTokenName = async (e: Event) => {\n    e.preventDefault();\n\n    console.log(\"TODO: apply params to raw validators\");\n  };\n\n  return (\n    <div>\n      {!lucid ? (\n        <form class=\"mt-10 grid grid-cols-1 gap-y-8\" onSubmit={setupLucid}>\n          <Input\n            type=\"password\"\n            id=\"blockfrostAPIKey\"\n            onInput={(e) => setBlockfrostAPIKey(e.currentTarget.value)}\n          >\n            Blockfrost API Key\n          </Input>","seq_id":14,"src":"tests/inputs/example--gift-card.mdx"},{"chunk":"<Button type=\"submit\">Setup Lucid</Button>\n        </form>\n      ) : (\n        <form class=\"mt-10 grid grid-cols-1 gap-y-8\" onSubmit={submitTokenName}>\n          <Input\n            type=\"text\"\n            name=\"tokenName\"\n            id=\"tokenName\"\n            value={tokenName}\n            onInput={(e) => setTokenName(e.currentTarget.value)}\n          >\n            Token Name\n          </Input>\n\n          {tokenName && <Button type=\"submit\">Make Contracts</Button>}\n        </form>\n      )}\n    </div>\n  );\n}\n```\n\n#### Apply params\n\nWe're going to use the `token_name` to apply some params to the raw validators. We can\ncreate a helper in `utils.ts` to do this for us.\n\n```ts filename=\"utils.ts\" {2-6,8}\nimport {\n  applyDoubleCborEncoding,\n  applyParamsToScript,\n  Constr,\n  fromText,\n  Lucid,\n  MintingPolicy,\n  OutRef,\n  SpendingValidator,\n} from \"lucid/mod.ts\";\n\n// ... export type Validators ...\n\n// ... export function readValidators(): Validators ...\n\nexport type AppliedValidators = {\n  redeem: SpendingValidator;\n  giftCard: MintingPolicy;\n  policyId: string;\n  lockAddress: string;\n};\n\nexport function applyParams(\n  tokenName: string,\n  outputReference: OutRef,\n  validators: Validators,\n  lucid: Lucid\n): AppliedValidators {\n  const outRef = new Constr(0, [\n    new Constr(0, [outputReference.txHash]),\n    BigInt(outputReference.outputIndex),\n  ]);","seq_id":15,"src":"tests/inputs/example--gift-card.mdx"},{"chunk":"const giftCard = applyParamsToScript(validators.giftCard.script, [\n    fromText(tokenName),\n    outRef,\n  ]);\n\n  const policyId = lucid.utils.validatorToScriptHash({\n    type: \"PlutusV2\",\n    script: giftCard,\n  });\n\n  const redeem = applyParamsToScript(validators.redeem.script, [\n    fromText(tokenName),\n    policyId,\n  ]);\n\n  const lockAddress = lucid.utils.validatorToAddress({\n    type: \"PlutusV2\",\n    script: redeem,\n  });\n\n  return {\n    redeem: { type: \"PlutusV2\", script: applyDoubleCborEncoding(redeem) },\n    giftCard: { type: \"PlutusV2\", script: applyDoubleCborEncoding(giftCard) },\n    policyId,\n    lockAddress,\n  };\n}\n```\n\nOur `applyParams` function expects a `tokenName`, an `output_Reference` that we'll fetch\nusing lucid in the island, `validators` that we got in the props, and a `lucid` instance. First we\ncreate `outRef` which is `PlutusData` using `outputReference`. Then we apply the `tokenName` and\n`outRef` to the `giftCard` validator. We then use `lucid` to get the `policyId` so that we can\napply `tokenName` and `policyId` to the `redeem` validator. Finally we use `lucid` to get the\n`lockAddress` so that we can return everything we need from the function. `lockAddress` is just the\naddress of the `redeem` validator which is where we'll send some assets that can be redeemed with the\ngift card. At this point we won't need to touch `utils.ts` again. We can use this new function in\n`islands/Oneshot.tsx` when a `tokenName` is submitted.","seq_id":16,"src":"tests/inputs/example--gift-card.mdx"},{"chunk":"```tsx filename=\"islands/Oneshot.tsx\" {2,8-9,18-33,39-51}\n// ... other imports ...\nimport { AppliedValidators, applyParams, Validators } from \"~/utils.ts\";\n\n// ... export interface AppProps ...\n\nexport default function App({ validators }: AppProps) {\n  // ... other useState ...\n  const [parameterizedContracts, setParameterizedContracts] =\n    useState<AppliedValidators | null>(null);\n\n  // ... const setupLucid = async (blockfrostApiKey: string) ...\n\n  // ... useEffect ...\n\n  const submitTokenName = async (e: Event) => {\n    e.preventDefault();\n\n    const utxos = await lucid?.wallet.getUtxos()!;\n\n    const utxo = utxos[0];\n    const outputReference = {\n      txHash: utxo.txHash,\n      outputIndex: utxo.outputIndex,\n    };\n\n    const contracts = applyParams(\n      tokenName,\n      outputReference,\n      validators,\n      lucid!\n    );\n\n    setParameterizedContracts(contracts);\n  };\n\n  return (\n    <div>\n      {/* ... {!lucid ? ... */}\n      {lucid && parameterizedContracts && (\n        <>\n          <h3 class=\"mt-4 mb-2\">Redeem</h3>\n          <pre class=\"bg-gray-200 p-2 rounded overflow-x-scroll\">\n            {parameterizedContracts.redeem.script}\n          </pre>","seq_id":17,"src":"tests/inputs/example--gift-card.mdx"},{"chunk":"<h3 class=\"mt-4 mb-2\">Gift Card</h3>\n          <pre class=\"bg-gray-200 p-2 rounded overflow-x-scroll\">\n            {parameterizedContracts.giftCard.script}\n          </pre>\n        </>\n      )}\n    </div>\n  );\n}\n```\n\nWe now have the power to create validators, that are usable on-chain, **completely on the fly**\npowered by some user input. You may already be getting all kinds of ideas on how to use this.\nBefore you go build the next big thing, let's use these newly generated validators in some\ntransactions.\n\n#### Mint and lock\n\nWe're going to mint some assets and lock them in the `lockAddress` that we got from\n`applyParams`. For the sake of keeping things simple, we'll only provide an input\nto capture some ADA amount to be locked. Technically the validators allow for any assets\nto be locked but it's easy to just support ADA for now. Along with an input, we want a button\nthat when clicked will run a function that builds, signs, and submits a transaction. When\nthe transaction is done we'll render the hash and have it link to cardano scan.\n\n```tsx filename=\"islands/Oneshot.tsx\" {2,10-12,20-81,89-122}\n// ... other imports ...\nimport { Blockfrost, Constr, Data, fromText, Lucid } from \"lucid/mod.ts\";\n\nimport { AppliedValidators, applyParams, Validators } from \"~/utils.ts\";\n\n// ... export interface AppProps ...","seq_id":18,"src":"tests/inputs/example--gift-card.mdx"},{"chunk":"export default function App({ validators }: AppProps) {\n  // ... other useState ...\n  const [giftADA, setGiftADA] = useState<string | undefined>();\n  const [lockTxHash, setLockTxHash] = useState<string | undefined>(undefined);\n  const [waitingLockTx, setWaitingLockTx] = useState<boolean>(false);\n\n  // ... const setupLucid = async (blockfrostApiKey: string) ...\n\n  // ... useEffect ...\n\n  // ... const submitTokenName = async (e: Event) ...\n\n  const createGiftCard = async (e: Event) => {\n    e.preventDefault();\n\n    setWaitingLockTx(true);\n\n    try {\n      const lovelace = Number(giftADA) * 1000000;\n\n      const assetName = `${parameterizedContracts!.policyId}${fromText(\n        tokenName\n      )}`;\n\n      // Action::Mint\n      // This is how you build the redeemer for gift_card\n      // when you want to perform the Mint action.\n      const mintRedeemer = Data.to(new Constr(0, []));\n\n      const utxos = await lucid?.wallet.getUtxos()!;\n      const utxo = utxos[0];\n\n      const tx = await lucid!\n        .newTx()\n        .collectFrom([utxo])\n        // use the gift_card validator\n        .attachMintingPolicy(parameterizedContracts!.giftCard)\n        // mint 1 of the asset\n        .mintAssets(\n          { [assetName]: BigInt(1) },\n          // this redeemer is the first argument to the gift_card validator\n          mintRedeemer\n        )\n        .payToContract(\n          parameterizedContracts!.lockAddress,\n          {\n            // On unlock this gets passed to the redeem\n            // validator as datum. Our redeem validator\n            // doesn't use it so we can just pass in anything.\n            inline: Data.void(),\n          },\n          { lovelace: BigInt(lovelace) }\n        )\n        .complete();","seq_id":19,"src":"tests/inputs/example--gift-card.mdx"},{"chunk":"const txSigned = await tx.sign().complete();\n\n      const txHash = await txSigned.submit();\n\n      const success = await lucid!.awaitTx(txHash);\n\n      // Wait a little bit longer so ExhaustedUTxOError doesn't happen\n      // in the next Tx\n      setTimeout(() => {\n        setWaitingLockTx(false);\n\n        if (success) {\n          setLockTxHash(txHash);\n        }\n      }, 3000);\n    } catch {\n      setWaitingLockTx(false);\n    }\n  };\n\n  return (\n    <div>\n      {/* ... {!lucid ? ... */}\n      {lucid && parameterizedContracts && (\n        <>\n          {/* ... show applied contracts ... */}\n          <div class=\"mt-10 grid grid-cols-1 gap-y-8\">\n            <Input\n              type=\"text\"\n              name=\"giftADA\"\n              id=\"giftADA\"\n              value={giftADA}\n              onInput={(e) => setGiftADA(e.currentTarget.value)}\n            >\n              ADA Amount\n            </Input>\n\n            <Button\n              onClick={createGiftCard}\n              disabled={waitingLockTx || !!lockTxHash}\n            >\n              {waitingLockTx\n                ? \"Waiting for Tx...\"\n                : \"Create Gift Card (Locks ADA)\"}\n            </Button>\n\n            {lockTxHash && (\n              <>\n                <h3 class=\"mt-4 mb-2\">ADA Locked</h3>","seq_id":20,"src":"tests/inputs/example--gift-card.mdx"},{"chunk":"<a\n                  class=\"mb-2\"\n                  target=\"_blank\"\n                  href={`https://preprod.cardanoscan.io/transaction/${lockTxHash}`}\n                >\n                  {lockTxHash}\n                </a>\n              </>\n            )}\n          </div>\n        </>\n      )}\n    </div>\n  );\n}\n```\n\nWith this code, we can now enter some ADA amount and then click a button to perform\nthe transaction. The transaction will mint a new asset using our token and send the ADA\nto the `redeem` validator's address, effectively locking the ADA.\n\n<Callout type=\"warning\">\n  It may be tempting to run this right now, but unless you cache some of the\n  data so far into local storage, you may find it hard to recover the locked\n  assets. We'll be writing more code which will require the app to be reloaded\n  and you will lose all your state including the uniquely parameterized `redeem`\n  validator's compiled code.\n</Callout>\n\n#### Burn and unlock\n\nThe final step in this example will be to redeem the gift card for the locked assets.\nSimilar to the previous section, we'll drive the transaction execution with a button click.\nAfter the redeem button is clicked and the transaction finishes we'll render the hash and\nhave it link to cardano scan like the previous section.\n\n```tsx filename=\"islands/Oneshot.tsx\" {7-10,20-73,96-103,107-119}\n// ... imports ...\n\n// ... export interface AppProps ...\n\nexport default function App({ validators }: AppProps) {\n  // ... other useState ...\n  const [unlockTxHash, setUnlockTxHash] = useState<string | undefined>(\n    undefined\n  );\n  const [waitingUnlockTx, setWaitingUnlockTx] = useState<boolean>(false);","seq_id":21,"src":"tests/inputs/example--gift-card.mdx"},{"chunk":"// ... const setupLucid = async (blockfrostApiKey: string) ...\n\n  // ... useEffect ...\n\n  // ... const submitTokenName = async (e: Event) ...\n\n  // ... const createGiftCard = async (e: Event) ...\n\n  const redeemGiftCard = async (e: Event) => {\n    e.preventDefault();\n\n    setWaitingUnlockTx(true);\n\n    try {\n      // get the utxos at the redeem validator's address\n      const utxos = await lucid!.utxosAt(parameterizedContracts!.lockAddress);\n\n      const assetName = `${parameterizedContracts!.policyId}${fromText(\n        tokenName\n      )}`;\n\n      // Action::Burn\n      // This is how you build the redeemer for gift_card\n      // when you want to perform the Burn action.\n      const burnRedeemer = Data.to(new Constr(1, []));\n\n      const tx = await lucid!\n        .newTx()\n        .collectFrom(\n          utxos,\n          // This is the second argument to the redeem validator\n          // and we also don't do anything with it similar to the\n          // inline datum. It's fine to pass in anything in this case.\n          Data.void()\n        )\n        // use the gift_card validator again\n        .attachMintingPolicy(parameterizedContracts!.giftCard)\n        // use the redeem validator\n        .attachSpendingValidator(parameterizedContracts!.redeem)\n        .mintAssets(\n          // notice the negative one here\n          { [assetName]: BigInt(-1) },\n          // this redeemer is the first argument to the gift_card validator\n          burnRedeemer\n        )\n        .complete();","seq_id":22,"src":"tests/inputs/example--gift-card.mdx"},{"chunk":"const txSigned = await tx.sign().complete();\n\n      const txHash = await txSigned.submit();\n\n      const success = await lucid!.awaitTx(txHash);\n\n      setWaitingUnlockTx(false);\n\n      if (success) {\n        setUnlockTxHash(txHash);\n      }\n    } catch {\n      setWaitingUnlockTx(false);\n    }\n  };\n\n  return (\n    <div>\n      {/* ... {!lucid ? ... */}\n      {lucid && parameterizedContracts && (\n        <>\n          {/* ... show applied contracts ... */}\n          <div class=\"mt-10 grid grid-cols-1 gap-y-8\">\n            {/* ... Create gift card ... */}\n\n            {lockTxHash && (\n              <>\n                <h3 class=\"mt-4 mb-2\">ADA Locked</h3>\n\n                <a\n                  class=\"mb-2\"\n                  target=\"_blank\"\n                  href={`https://preprod.cardanoscan.io/transaction/${lockTxHash}`}\n                >\n                  {lockTxHash}\n                </a>\n\n                <Button\n                  onClick={redeemGiftCard}\n                  disabled={waitingLockTx || !!unlockTxHash}\n                >\n                  {waitingUnlockTx\n                    ? \"Waiting for Tx...\"\n                    : \"Redeem Gift Card (Unlocks ADA)\"}\n                </Button>\n              </>\n            )}\n\n            {unlockTxHash && (\n              <>\n                <h3 class=\"mt-4 mb-2\">ADA Unlocked</h3>","seq_id":23,"src":"tests/inputs/example--gift-card.mdx"},{"chunk":"<a\n                  class=\"mb-2\"\n                  target=\"_blank\"\n                  href={`https://preprod.cardanoscan.io/transaction/${unlockTxHash}`}\n                >\n                  {unlockTxHash}\n                </a>\n              </>\n            )}\n          </div>\n        </>\n      )}\n    </div>\n  );\n}\n```\n\nWe've now completed the example and have a fun little prototype.\n\n## Conclusion\n\nHopefully this gives you ideas on what you can build on Cardano. This example should\nalso illustrate how most of the code in your dapp isn't even the validators. When designing\napplications that leverage Cardano it's always better to think about what kinds of transactions\nyou'll need to construct and then writing your validators to enforce them. A full reference\nto this example can be found [here](https://github.com/aiken-lang/aiken/tree/main/examples/gift_card).","seq_id":24,"src":"tests/inputs/example--gift-card.mdx"}]