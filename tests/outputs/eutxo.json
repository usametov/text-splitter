[{"chunk":"import { Callout } from \"nextra-theme-docs\";\n\n<style>{`\n@font-face {\n  font-family: 'Menlo Regular';\n  font-style: normal;\n  font-weight: normal;\n  src: local('Menlo Regular'), url('/fonts/Menlo-Regular.woff') format('woff');\n}\npre code {\n  line-height: 1rem !important;\n  font-family: \"Menlo Regular\" !important;\n}\n`}</style>\n\n# EUTxO crash course\n\nIf you have absolutely no idea what developing on Cardano looks like, worry\nnot. You just found the right piece to get started. Aiken is a language platform\nthat makes on-chain programming easy. But what is _\"on-chain programming\"_ to\nbegin with? While this succinct documentation piece has no ambition to be a\ncomplete course on blockchains, it should give you enough insights to build a\nbasic understanding of the fundamentals.\n\n<Callout type=\"warning\">\n  This course will reference cryptography concepts such as **hash digests** or\n  **digital signatures**. We, therefore, expect readers to be either familiar\n  with those concepts (at least a tiny bit) or to read up on them. There are\n  plenty of resources available in the wild regarding cryptography and this\n  crash course **isn't** one of them.\n\n  As a suggestion, if you want to learn more on those fundamentals, we\n  heartwarmingly recommend [Cardano Blockchain Certified Associate (CBCA)'s first\n  module](https://academy.cardanofoundation.org/).\n</Callout>\n\n## Blocks & transactions\n\nBlockchains are made of blocks. And blocks are made of transactions. Without\ngoing into the details, you can think of blocks as being objects divided into\ntwo parts: a header and a body. The header contains information about the\nblocks, such as who produced them and when they were made. The body is nothing\nmore than an ordered sequence of transactions.","seq_id":0,"src":"tests/inputs/eutxo.mdx"},{"chunk":"Note that the _\"chain\"_ of blockchain comes from how blocks reference one\nanother. Indeed, each block header includes at least two things:\n\n- A hash digest of the block body\n- A hash digest of the previous block header\n\n```console filename=\"Block\"\n┏━ Header ━━━━━━━━━━━━━━┳━ Body ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓\n┃                       ┃                                           ┃\n┃  Body hash            ┃ ┌────────────────┬────────────────┬─────┐ ┃\n┃  Previous header hash ┃ │ Transaction #1 │ Transaction #2 │ ... │ ┃\n┃  Timestamp            ┃ └────────────────┴────────────────┴─────┘ ┃\n┃                       ┃                                           ┃\n┗━━━━━━━━━━━━━━━━━━━━━━━┻━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛\n```\n\nA hash digest is a tamper-proof mechanism that maps an input value to a\nfixed-sized output. Think of it as a way to assign an identifier to a piece of\ncontent, such that the identifier depends on the content itself: change the\ncontent, change the identifier.\n\nA chain is formed by including in every block header:\n\n- a hash of the block body; and\n- a header hash of the previous block.\n\nChanging any transaction in a block will change the block body hash, thus\nchanging the block header hash, the header hash of the next block, and so on,\ninvalidating the entire chain that follows.\n\n```\n        ____          ____          ____          ____          ____\n       /    /\\       /    /\\       /    /\\       /    /\\       /    /\\\no ❮❮  /____/  \\ ❮❮  /____/  \\ ❮❮  /____/  \\ ❮❮  /____/  \\ ❮❮  /____/  \\ ...\n      \\    \\  /     \\    \\  /     \\    \\  /     \\    \\  /     \\    \\  /\n╿      \\____\\/       \\____\\/       \\____\\/       \\____\\/       \\____\\/\n│\n│                                     ╿\n│                                     │\n└ Genesis configuration               │\n                                      └ Block\n```","seq_id":1,"src":"tests/inputs/eutxo.mdx"},{"chunk":"A transaction is, therefore, the most fundamental primitive on blockchains.\nThey are the mechanism whereby users (a.k.a you) can take actions to change the\nstate of the blockchain. A chain starts from an initial state typically\nreferred to as _genesis configuration_. And from there, transactions map a\nprevious state into a new state. Finally, blocks are merely there to batch\ntransactions together.\n\n## Unspent Transaction Outputs\n\nIn the traditional database world, a _transaction_ is a means to bundle\ntogether a series of atomic operations so that all are successful or none\nhappen. In the financial world, it is a way to transfer assets from one\nlocation to another.\n\nIn the blockchain world, it is a bit of both.\n\nA transaction is, first and foremost, an object with an input from where it\ntakes assets and an output to where it sends them. Often, as is the case in\nCardano, transactions have many inputs and many outputs. And, in addition to\ninputs and outputs, blockchain protocols often include other elements that\nmodify different parts of the blockchain state (e.g. delegation certificates,\ngovernance votes, user-defined assets definitions...)\n\nMore so, like in the database world, a transaction is an all-or-nothing atomic\nseries of commands. Either it is valid, and all its changes are applied, or it\nisn't, and none are applied.\n\nWe'll talk more about other capabilities later. For now, let's focus on inputs\nand outputs, starting with the outputs.\n\n### Outputs\n\nIn Cardano, an output is an object that describes at least two things:\n\n- a quantity of assets -- also known as, a _value_;\n- a condition for spending (and/or delegating) those assets -- also known as an _address_.\n\nIn addition, a data payload can also be added to outputs but let's not bother\nwith that just now. The role of the value is pretty transparent, and it\nindicates how many assets hold the output.","seq_id":2,"src":"tests/inputs/eutxo.mdx"},{"chunk":"Incidentally, Cardano supports two kinds of assets: the main protocol currency\n(a.k.a. Ada); and user-defined currencies. Both live side-by-side in values\nthough slightly different rules apply to each.\n\nThe address captures the logic that tells the protocol under what conditions\none can utilize the assets at a particular output. It is what defines ownership\nof the assets. We'll explore this very soon. Bear with us a little more.\n\n```console filename=\"Output\"\n┏━━━━━━━━━┳━━━━━━━━━━━┳━━━━━━━━━━━━━━━━┓\n┃         ┃           ┃                ┃\n┃  Value  ┃  Address  ┃  Data payload  ┃\n┃         ┃           ┃                ┃\n┗━━━━━━━━━┻━━━━━━━━━━━┻━━━━━━━━━━━━━━━━┛\n```\n\n### Inputs\n\nAn input is a reference to a previous output. Think of outputs as post-it notes\nwith a unique serial number and inputs as being this serial number.\n\n![](/post-it-notes.jpg)\n\nA transaction is a document indicating which post-it notes should be destroyed\nand which new ones should be pinned to the wall. Note that there are rules\nregarding the construction of transactions. For example, there must be as much\nvalue in as there's value out. Said differently, the total value should balance\nout but might be shuffled differently.\n\nAn output that hasn't been spent yet (i.e. is still on the wall) is called --\nyou guessed it -- an _unspent transaction output_, or UTxO in short. The\nblockchain state results from looking at the entire wall of remaining post-it\nnotes. In addition to all of the available UTxOs, the state also includes any additional data\ndefined by the protocol.\n\nOkay, back to inputs.\n\nTechnically speaking, an input's _\"serial number\"_ is the hash digest of the\ntransaction that emitted the output it refers to and the position of the output\nwithin that transaction. These two elements make each input unique. And because\noutputs are removed from the available set (the post-it note is destroyed) when\nspent, they can only be spent once. This is ensured by the blockchain\nprotocol.","seq_id":3,"src":"tests/inputs/eutxo.mdx"},{"chunk":"```console filename=\"Input\"\n┏━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━┓\n┃                    ┃                ┃\n┃  Transaction hash  ┃  Output index  ┃\n┃                    ┃                ┃\n┗━━━━━━━━━━━━━━━━━━━━┻━━━━━━━━━━━━━━━━┛\n```\n\n<Callout type=\"info\">\nWhere do the first outputs come from?\n\nIf you've carefully followed the narrative we just went through, you might have\nrealized that we have a chicken-and-egg situation. Inputs are references to\noutputs. And outputs are created by spending inputs.\n\nThis is what the genesis configuration is for. It defines the starting point of\nthe blockchain in the form of an agreed-upon initial list of outputs. Those\noutputs can be referred to using some special identifiers. For example, the\ngenesis configuration hash digest and the output's position in the\nconfiguration.\n\nHow the genesis configuration comes to be is also an interesting question but\nout of the scope of the current course. In the case of Cardano, the initial\ndistribution resulted from an initial token vouchers sale where a portion of the\ntotal Ada supply was sold in the form of vouchers to stakeholders before the\nlaunch of the network.\n\n</Callout>\n\n### TL;DR\n\nLet's quickly recap what we've seen so far:\n\n- A blockchain has an initial state called a _genesis configuration_;\n- A _transaction_ captures instructions to modify that state (e.g. transfer of assets);\n- A _block_ batches transactions together and has a reference to a parent block;\n- Assets movement are expressed using _inputs_ and _outputs_ in transactions;\n- An _output_ is an object with at least an _address_ and a _value_;\n- An _address_ describes the conditions needed to use the _value_ associated with it;\n- An _input_ is a reference to a previous _output_.\n\n## Addresses\n\n### Overview\n\nIt is now time to delve more into Cardano addresses. A typical address is made\nof 2 or 3 parts:","seq_id":4,"src":"tests/inputs/eutxo.mdx"},{"chunk":"```console filename=\"Address\"\n┏━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━┓\n┃          ┃                       ┃                          ┃\n┃  Header  ┃  Payment credentials  ┃  Delegation credentials  ┃\n┃          ┃                       ┃                          ┃\n┗━━━━━━━━━━┻━━━━━━━━━━━━━━━━━━━━━━━┻━━━━━━━━━━━━━━━━━━━━━━━━━━┛\n```\n\nWe said 2 or 3 because the last part -- the delegation credentials -- is\noptional. The first part is called the `Header`, and it describes the type of\naddress (i.e. what comes next) and the network within which this address can be\nused. We call that last bit a _network discriminant_ and it prevents silly\nmistakes like sending real Mainnet funds to a test address. An address is\nrepresented as a sequence of bytes, usually encoded using\n[bech32](https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki#user-content-Introduction)\nor simply [base16](https://en.wikipedia.org/wiki/Hexadecimal) text strings.\n\nFor example:\n\n```console filename=\"An address (bech32)\"\naddr1x8phkx6acpnf78fuvxn0mkew3l0fd058hzquvz7w36x4gt7r0vd4msrxnuwnccdxlhdjar77j6lg0wypcc9uar5d2shskhj42g\n```\n\nor alternatively\n\n```console filename=\"The same address (base16)\"\n31c37b1b5dc0669f1d3c61a6fddb2e8fde96be87b881c60bce8e8d542fc37b1b5dc0669f1d3c61a6fddb2e8fde96be87b881c60bce8e8d542f\n```\n\nWe can dissect the latter text string to make the three parts mentioned above more apparent:\n\n```\n               Type = 3 ┐┌ Network = 1 (1 = mainnet, 0 = testnet)\n                        ││\n                        ╽╽\nHeader:                 31\nPayment credentials:    c37b1b5dc0669f1d3c61a6fddb2e8fde96be87b881c60bce8e8d542f\nDelegation credentials: c37b1b5dc0669f1d3c61a6fddb2e8fde96be87b881c60bce8e8d542f\n```","seq_id":5,"src":"tests/inputs/eutxo.mdx"},{"chunk":"As we can see, this address is a type 3, is for mainnet and uses the same\ncredentials for both the payment and the delegation part.\n\n<Callout type=\"info\">\n  You will often need to convert back-and-forth between bech32-encoded strings\n  and hex-encoded strings. A great command-line tool for working with bech32 can\n  be found at\n  [input-output-hk/bech32](https://github.com/input-output-hk/bech32#bech32-command-line).\n  Use it!\n</Callout>\n\n### Payment credentials\n\nThe next part is the _payment credentials_, also called the _payment part_.\nThis is what describes the spending conditions for the address. Remember how\nUTxOs are like post-it notes on a wall? Well, you don't get to hang them or pick\nthem up directly yourself. You have to hand over a _transaction_ to the network\nvalidators. Imagine an employee who's gatekeeping the wall of post-it notes and\nto whom you must give a form that describes what you want to do. Written on each post-it\nnote are the conditions that must be met before it can be picked up and destroyed. That's what the payment credentials are for in the address. They come in\none of two forms:\n\n- a verification key hash digest; or\n- a script hash digest.\n\nIn the first form, the validator nodes -- or the employee -- will ask you to\nprovide a digital signature from the signing key corresponding to the\nverification key. This approach relies on asymmetric cryptography, where one\ngenerates credentials as a public (verification) and private (signing) key\npair. In the address, we store only a hash digest of the verification key for\nconciseness and to avoid revealing it too early (even though it is public\nmaterial). When spending from such an address, one must reveal the public key\nand show a signature of the entire transaction as _witnesses_ (a.k.a proofs).\nThis way of specifying spending conditions is relatively straightforward but\nalso constrained because it doesn't allow for expressing any elaborate logic.","seq_id":6,"src":"tests/inputs/eutxo.mdx"},{"chunk":"This is where the second form gets more interesting. Cardano allows locking\nfunds using a script representing the validation logic that must be satisfied\nto spend funds guarded by the address. We typically call such addresses\n\"_script addresses_\". Similarly to the first form, the entire script must be\nprovided as a witness by any transaction spending from a script address, as\nwell as any other elements required by the script. Scripts are like predicates.\nSaid differently, they are functions that return a boolean value: `True` or\n`False`. To be considered valid, all scripts in a transaction must return\n`True`. We'll explore how this mechanism works in a short moment.\n\n### Delegation credentials\n\nAddresses may also contain _delegation credentials_, also called a _delegation\npart_. We will only go a little into the details here, but think of the delegation\ncredentials as a way to control what can be done with the _stake_ associated with\nthe address. The _stake_ corresponds to the Ada quantity in the output's value\nthat the consensus protocol counts to elect block producers. In Cardano,\nthe stake can be delegated to registered entities called stake pools. By\ndelegating, one indicates that the stake associated with an output should be\ncounted as if it belonged to the delegatee, increasing their chance of\nproducing a block. In return, the delegatee agrees to share a portion of their\nblock-producing rewards with the delegator.\n\nWhile the payment credentials control how to **spend** an output, delegation\ncredentials control two separate operations:\n\n- how to **publish** a delegation certificate (e.g. to delegate stake to a stake pool);\n- how to **withdraw** rewards associated with the stake credentials.\n\nLike payment credentials, delegation credentials comes in two forms: as\nverification key hash digest or as script hash digest.\n\n<Callout type=\"info\">\n  More information about addresses and how they work can be found in\n  [CIP-0019](https://github.com/cardano-foundation/CIPs/tree/master/CIP-0019/#readme)\n</Callout>","seq_id":7,"src":"tests/inputs/eutxo.mdx"},{"chunk":"### TL;DR\n\n#\n\n```console filename=\"Address\"\n                        ┌ For spending\n                        │\n                        ╽\n┏━ Header ━━━━━━━━━━━━━┳━ Payment credentials ━━━━━━━┳━ Delegation credentials ━━━━┓\n┃                      ┃                             ┃                             ┃\n┃                      ┃  ┌───────────────────────┐  ┃  ┌───────────────────────┐  ┃\n┃  ┌──────┬─────────┐  ┃  │ Verification key hash │  ┃  │ Verification key hash │  ┃\n┃  │ Type │ Network │  ┃  ├────────── OR ─────────┤  ┃  ├────────── OR ─────────┤  ┃\n┃  └──────┴─────────┘  ┃  │      Script hash      │  ┃  │      Script hash      │  ┃\n┃                      ┃  └───────────────────────┘  ┃  └───────────────────────┘  ┃\n┃                      ┃                             ┃                             ┃\n┗━━━━━━━━━━━━━━━━━━━━━━┻━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┻━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛\n                                                      ╿\n                                                      │\n                                                      └ For:\n                                                          - publishing certificates\n                                                          - withdrawing rewards\n```\n\nBefore we move on, let's recap again:\n\n- An _address_ is made up of either 2 or 3 parts: it always contains a _header_ and _payment credentials_, and may optionally also contain _delegation credentials_;\n- The _header_ describes the _type_ of address and the _network_ it is for;\n- the _delegation credentials_ part, while optional, is still <u>highly recommended</u>;\n- Credentials (payment or delegation) take one of two forms:\n  - a verification key hash;\n  - a script hash;\n- Payment credentials control how to **spend** from an _address_;\n- Delegation credentials control how to **publish** certificates and how to **withdraw** rewards;\n- A script allows the definition of arbitrary validation logic.\n\n## Scripts, Datums and Redeemers\n\n### Overview\n\nHang in there! We are almost at the end of this crash course. We've had a look at what\nUTxOs are and what addresses are made of, and we spoke a bit about scripts. In\nparticular, we said that scripts are like predicates: that is, pure functions\n(in the mathematical sense) that take a transaction as an argument and return\neither `True` or `False`.","seq_id":8,"src":"tests/inputs/eutxo.mdx"},{"chunk":"Well, _not exactly_. We lied to you (but only a tiny bit).\n\nIf we only had that, it would be hard to express more elaborate logic. In\nparticular, capturing a state, which programs often require, would be\ninfeasible. A state and transitions from that state. This is where the\n_extended UTxO_ model comes in. It adds two new components to what we've\nalready seen: datums and redeemers.\n\nWe mentioned the datum earlier without calling it a datum when we said that\noutputs contained a value, an address and a data payload. This is what the\ndatum is, a free payload that developers can use to attach data to script\nexecution. When a script is executed in a spending scenario, it receives not\nonly the transaction as context but also the datum associated with the output\nbeing spent.\n\nThe redeemer, on the other hand, is another piece of data that is also provided\nwith the transaction for any script execution. Notice that the datum and\nredeemer intervene at two distinct moments. A datum is set when the output is\ncreated (i.e. when the post-it note is hung on the wall, it is part of the\nnote). In contrast,  the redeemer is provided only when spending the output (i.e.\nprovided along with the form as it is handed over to the employee).\n\n### Analogy\n\nAnother way to look at scripts, datums and redeemers is to think of them together as forming\nparameterised mathematical functions.\n\n```console filename=\"Script, datum and redeemer\"\n             Script\n          ╭─────────╮\n    f(x) = x * a + b  = true | false\n           ╿   ╿   ╿\n  Redeemer ┘   │   │\n               └─┬─┘\n               Datum\n```\n\nThe script defines the function as a whole. It indicates how the parameters and\narguments are combined to produce a boolean outcome. The datum corresponds to\nthe parameters of the function. It allows _configuring the function_ and\nre-using a similar validation logic with different settings. Both the function\nand the parameters are defined when assets are locked in an output. Which\nleaves only the function argument to be later provided. That argument is the\nredeemer (as well as the rest of the transaction).","seq_id":9,"src":"tests/inputs/eutxo.mdx"},{"chunk":"This is why scripts are often referred to as _validators_. Unlike some other\nblockchain systems, they are also, therefore, fully deterministic. Their\nexecution only depends on the transaction they're involved with, and evaluating\nthe transaction's outcome is possible before sending it to the network. Datums\nact as local states, and redeemers are user inputs provided in the transaction\nitself.\n\n<Callout type=\"info\">\n  If we take a step back and look at the typical public/private key procedure\n  for spending funds, we can see how eUTxO is merely a generalization of that.\n  Indeed, the public key (hash) can be seen as _the datum_, whereas the\n  signature is the _redeemer_. The script is the digital signature verification\n  algorithm that controls whether the signature is valid w.r.t. the provided key.\n</Callout>\n\n### Purposes\n\nSo far, we've mostly talked about scripts in the context of validating whether\nan output can be spent. We've also briefly mentioned earlier how scripts can be\nused to control the publication of delegation certificates or how consensus\nrewards can be withdrawn.\n\nThese different use cases are commonly referred to as script purposes. Until\nnow, we've seen three purposes: `spend`, `publish` and `withdraw`. There's a\nfourth one: `mint`.\n\nThe mint purpose refers to scripts that are executed to validate whether\nuser-defined assets can be minted (i.e. created) or burned (i.e. destroyed).\nCardano indeed supports user-defined assets which are used to represent both\nfungible quantities (like a protocol currency) or non-fungible quantities\n(a.k.a NFTs).\n\nThe rules that govern the creation or destruction of an asset are defined as a\nscript. We often refer to such scripts as _minting policies_, which correspond\nto the `mint` purpose above.","seq_id":10,"src":"tests/inputs/eutxo.mdx"},{"chunk":"Each purpose, therefore, indicates _for what purpose_ a script is being\nexecuted. During validation, that information is passed to the script alongside\nthe transaction and the redeemer. Note that only scripts executed with the\n`spend` purpose are given a datum. This is because they can leverage the data\npayload present in outputs, unlike the other purposes that do not get this\nopportunity.\n\n### TL;DR\n\nAnd we've reached the end of this crash course. Let's do a final recap\nregarding scripts, datums and redeemers.\n\n- _Scripts_ are akin to parameterized predicate functions, returning either true or false.\n- _Datums_ take the role of function parameters, whereas _redeemers_ the one of argument.\n- _Scripts_ are also called _validators_ and are completely deterministic.\n- _Scripts_ are used to validate specific operations in a transaction.\n- What a _script_ is used for is referred to as its _purpose_. There are 4 purposes:\n  - `spend` -- controls how to spend outputs;\n  - `publish` -- controls how to publish delegation certificates;\n  - `withdraw` -- controls how to withdraw consensus rewards;\n  - `mint` -- controls how to mint or burn assets.\n- Only _spending scripts_ (i.e. purpose=spend) have access to a datum.","seq_id":11,"src":"tests/inputs/eutxo.mdx"}]