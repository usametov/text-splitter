[{"chunk":"import { Callout } from \"nextra-theme-docs\";\n\n# Vesting\n\nArmed with our recently acquired knowledge from the _Hello, World!_ contract,\nlet's increase the difficulty and write a slightly more challenging one.\n\nA vesting contract is a common type of contract that allows to lock funds for a\nperiod of time, only to unlock them later -- once a specified time has passed.\nUsually, vesting contract defines a beneficiary who can be different from the\noriginal owner.\n\n## Covered in this tutorial\n\n<br/>\n\n- [x] Writing non-trivial Aiken validators, with complex datums.\n- [x] Using more advanced Aiken features (type-aliases, pattern-matches)\n- [x] Writing unit tests using Aiken's built-in test framework\n- [x] Managing time on-chain through transaction validity ranges\n\n<Callout type=\"info\" emoji=\"ðŸ“˜\">\n  When encountering an unfamiliar syntax or concept, do not hesitate to refer to\n  the [language-tour](/language-tour) for details and extra examples.\n</Callout>\n\n## Setup\n\nIn a similar fashion to what we did for the _Hello, World!_ contract, we'll\nneed some credentials (and funds) to play around with. Here, we define an extra\nkey for the beneficiary. Again, use the [Cardano\nfaucet](https://docs.cardano.org/cardano-testnet/tools/faucet) to receive test\nfunds. Refer to [Hello World :: Getting\nFunds](/getting-started/hello-world#getting-funds) in case you have any doubts\non the procedure.\n\n```ts filename=\"deno repl --allow-net --allow-write\"\nimport { Lucid } from \"https://deno.land/x/lucid@0.8.3/mod.ts\";","src":"tests/inputs/example--vesting.mdx"},{"chunk":"const lucid = await Lucid.new(undefined, \"Preview\");\n\nconst ownerPrivateKey = lucid.utils.generatePrivateKey();\nawait Deno.writeTextFile(\"owner.sk\", ownerPrivateKey);\n\nconst ownerAddress = await lucid\n  .selectWalletFromPrivateKey(ownerPrivateKey)\n  .wallet.address();\nawait Deno.writeTextFile(\"owner.addr\", ownerAddress);\n\nconst beneficiaryPrivateKey = lucid.utils.generatePrivateKey();\nawait Deno.writeTextFile(\"beneficiary.sk\", beneficiaryPrivateKey);\n\nconst beneficiaryAddress = await lucid\n  .selectWalletFromPrivateKey(beneficiaryPrivateKey)\n  .wallet.address();\nawait Deno.writeTextFile(\"beneficiary.addr\", beneficiaryAddress);\n```\n\n## On-Chain code\n\nLet's write our time lock validator as `validators/vesting.ak`, starting with\nthe definition of its interface (i.e. its datum's shape).\n\n```aiken filename=\"validators/vesting.ak\"\nuse aiken/hash.{Blake2b_224, Hash}\nuse aiken/transaction/credential.{VerificationKey}\n\ntype Datum {\n  /// POSIX time in second, e.g. 1672843961000\n  lock_until: POSIXTime,\n  /// Owner's credentials\n  owner: VerificationKeyHash,\n  /// Beneficiary's credentials\n  beneficiary: VerificationKeyHash,\n}","src":"tests/inputs/example--vesting.mdx"},{"chunk":"type VerificationKeyHash =\n  Hash<Blake2b_224, VerificationKey>\n\ntype POSIXTime =\n  Int\n```\n\nAs we can see the script's datum serves as configuration and contains the\ndifferent parameters of our vesting operation. Remember that these elements are\nset when locking funds in the contract; combined with the script they define\nthe conditions by which the funds can be released.\n\nFrom there, lets define the `spend` validator itself.\n\n```aiken filename=\"validators/vesting.ak\"\nuse aiken/interval.{Finite}\nuse aiken/list\nuse aiken/transaction.{Transaction, ScriptContext, Spend, ValidityRange}\n\nvalidator {\n  fn vesting(datum: Datum, _redeemer: Void, ctx: ScriptContext) {\n    // In principle, scripts can be used for different purpose (e.g. minting\n    // assets). Here we make sure it's only used when 'spending' from a eUTxO\n    when ctx.purpose is {\n      Spend(_) ->\n        or {\n          must_be_signed_by(ctx.transaction, datum.owner),\n          and {\n            must_be_signed_by(ctx.transaction, datum.beneficiary),\n            must_start_after(ctx.transaction.validity_range, datum.lock_until),\n          },\n        }\n      _ -> False\n    }\n  }\n}\n\nfn must_be_signed_by(transaction: Transaction, vk: VerificationKeyHash) {\n  list.has(transaction.extra_signatories, vk)\n}\n\nfn must_start_after(range: ValidityRange, lock_expiration_time: POSIXTime) {\n  when range.lower_bound.bound_type is {\n    Finite(tx_earliest_time) -> lock_expiration_time <= tx_earliest_time\n    _ -> False\n  }\n}\n```","src":"tests/inputs/example--vesting.mdx"},{"chunk":"The novelty here mostly lies in the check against a time period. In fact,\ntransactions can have validity intervals that define from when and until when\nthe transaction is considered valid. Validity bounds are checked by the ledger\nprior to executing a script and only does so if the bounds are legit.\n\nThis is meant to give scripts a notion of time, while preserving determinism\nfrom within the context of a script. For example, in this scenario, given a\nlower bound `A` on the transaction, we can deduce that the current time is _at\nleast_ `A`.\n\nNote that because we don't control the upper-bound, it could very much be that\nthis transaction is executed 30 years after the vesting delay. Yet, from the\nperspective of the vesting script, this is perfectly okay.\n\nSee also how we annotate the redeemer to `Void` to indicate that it isn't used.\nWe could also leave it unannotated but it's generally good to signal your intent\nexplicitly. `Void` captures that pretty well.\n\n### Testing\n\nOkay, now before deploying our contract in the wild and risking collapsing the\neconomy with some unforeseen bug, let's write a few tests. Aiken has builtin\nsupport for tests, which are very much like functions that takes no argument\nand must return a `Bool{:ak}`.\n\nTests can use any function, constant or types defines in our module but beware,\nthey cannot reference other tests!\n\n```aiken filename=\"validators/vesting.ak\"\nuse aiken/interval.{Finite, Interval, IntervalBound, PositiveInfinity}\n\ntest must_start_after_succeed_when_lower_bound_is_after() {\n  must_start_after(interval.after(2), 1)\n}\n\ntest must_start_after_succeed_when_lower_bound_is_equal() {\n  must_start_after(interval.after(2), 2)\n}","src":"tests/inputs/example--vesting.mdx"},{"chunk":"test must_start_after_fail_when_lower_bound_is_before() {\n  !must_start_after(interval.after(2), 3)\n}\n```\n\n<Callout>\n  You can run tests with `aiken check`; Aiken will collect and run all tests\n  found in your modules, and give you some statistics about the execution units\n  (CPU and memory) required by the test.\n</Callout>\n\n### Building\n\nIt's now time to build our on-chain contract! Simply do:\n\n```\naiken build\n```\n\nThis generate a [CIP-0057 Plutus blueprint](https://github.com/cardano-foundation/CIPs/pull/258) as `plutus.json` at the root of your project. This blueprint describes your on-chain contract and its binary interface. In particular, it contains the generated on-chain code that will be executed by the ledger, and a hash of your validator(s) that can be used to construct addresses.\n\nLet's see the validator in action!\n\n## Off-Chain code\n\nAs a starter, we need to lock funds in our newly created contract. We'll use\n[`Lucid`](https://github.com/spacebudz/lucid) to construct and submit our\ntransaction through Blockfrost.\n\n<Callout type=\"info\">\n  This is only one example of possible setup using tools we love. For more\n  tools, make sure to check out the [Cardano Developer\n  Portal](https://developers.cardano.org/tools)!\n</Callout>\n\n### Setup\n\nFirst, we setup Lucid with Blockfrost as a provider. You know the drill from\nthe [_Hello, World!_](/getting-started/hello-world) example already.","src":"tests/inputs/example--vesting.mdx"},{"chunk":"```ts filename=\"vesting_lock.ts\"\nimport {\n  Blockfrost,\n  C,\n  Data,\n  Lucid,\n  SpendingValidator,\n  TxHash,\n  fromHex,\n  toHex,\n} from \"https://deno.land/x/lucid@0.8.3/mod.ts\";\nimport * as cbor from \"https://deno.land/x/cbor@v1.4.1/index.js\";\n\nconst lucid = await Lucid.new(\n  new Blockfrost(\n    \"https://cardano-preview.blockfrost.io/api/v0\",\n    Deno.env.get(\"BLOCKFROST_API_KEY\"),\n  ),\n  \"Preview\",\n);\n\nlucid.selectWalletFromPrivateKey(await Deno.readTextFile(\"./owner.sk\"));\n\nconst validator = await readValidator();\n\n// --- Supporting functions\n\nasync function readValidator(): Promise<SpendingValidator> {\n  const validator = JSON.parse(await Deno.readTextFile(\"plutus.json\")).validators[0];\n  return {\n    type: \"PlutusV2\",\n    script: toHex(cbor.encode(fromHex(validator.compiledCode))),\n  };\n}\n```\n\n<Callout>\n  If you've installed [deno](https://deno.land/manual@v1.29.1/getting_started/installation), you can run the except above by executing:","src":"tests/inputs/example--vesting.mdx"},{"chunk":"```\ndeno run --allow-net --allow-read --allow-env vesting_lock.ts\n```\n\nIt assumes that this file (`vesting_lock.ts`) is placed at the root of your `vesting` folder. At this stage, your folder should looks roughly like this:\n\n```\n./vesting\nâ”‚\nâ”œâ”€â”€ README.md\nâ”œâ”€â”€ aiken.toml\nâ”œâ”€â”€ plutus.json\nâ”œâ”€â”€ vesting_lock.ts\nâ”œâ”€â”€ owner.addr\nâ”œâ”€â”€ owner.sk\nâ”œâ”€â”€ beneficiary.addr\nâ”œâ”€â”€ beneficiary.sk\nâ”œâ”€â”€ lib\nâ”‚Â Â  â””â”€â”€ ...\nâ””â”€â”€ validators\n Â Â  â””â”€â”€ vesting.ak\n```\n\n</Callout>\n\n### Locking funds into the contract\n\nHere, we make our first transaction to lock funds into the contract. The datum\nmust match the representation expected by the script, constructor is an object expecting 3 fields.\n\n```ts filename=\"vesting_lock.ts\"\nconst ownerPublicKeyHash = lucid.utils.getAddressDetails(\n  await lucid.wallet.address()\n).paymentCredential.hash;\n\nconst beneficiaryPublicKeyHash =\n  lucid.utils.getAddressDetails(await Deno.readTextFile(\"beneficiary.addr\"))\n    .paymentCredential.hash;\n\nconst Datum = Data.Object({\n  lock_until: Data.BigInt, // this is POSIX time, you can check and set it here: https://www.unixtimestamp.com\n  owner: Data.String, // we can pass owner's verification key hash as byte array but also as a string\n  beneficiary: Data.String, // we can beneficiary's hash as byte array but also as a string\n});","src":"tests/inputs/example--vesting.mdx"},{"chunk":"type Datum = Data.Static<typeof Datum>;\n\nconst datum = Data.to<Datum>(\n  {\n    lock_until: 1672843961000n, // Wed Jan 04 2023 14:52:41 GMT+0000\n    owner: ownerPublicKeyHash, // our own wallet verification key hash\n    beneficiary: beneficiaryPublicKeyHash,\n  },\n  Datum\n);\n\nconst txLock = await lock(1000000, { into: validator, datum: datum });\n\nawait lucid.awaitTx(txLock);\n\nconsole.log(`1 tADA locked into the contract\n    Tx ID: ${txLock}\n    Datum: ${datum}\n`);\n\n// --- Supporting functions\n\nasync function lock(lovelace, { into, datum }): Promise<TxHash> {\n  const contractAddress = lucid.utils.validatorToAddress(into);\n\n  const tx = await lucid\n    .newTx()\n    .payToContract(contractAddress, { inline: datum }, { lovelace })\n    .complete();\n\n  const signedTx = await tx.sign().complete();\n\n  return signedTx.submit();\n}\n```\n\n### Unlocking funds from the contract\n\nNow we can use another wallet (beneficiary.sk). This wallet will be beneficiary\nwallet had been added into datum in the previous step (locking) as well.\n\nFinally, as a last step: we now want to spend the UTxO that is locked by our\n`vesting` contract.","src":"tests/inputs/example--vesting.mdx"},{"chunk":"To be valid, our transaction must meet one of two conditions:\n\n- it must be signed by the owner referenced as \"owner\" in the datum; or\n- it must be signed by the beneficiary referenced as \"beneficiary\" in the datum\n  AND time has to pass beyond the threshold we fixed -- that is it needs to be\n  later than 'Wed Jan 04 2023 14:52:41 GMT+0000'.\n\nLike for the _Hello, World!_ example, we need to explicitly add a signer using\n`.addSigner` so that it gets added to the `extra_signatories` of our\ntransaction and becomes accessible for our script.\n\nIn addition we need to specify `.validFrom` as a POSIX timestamp from where\ntransaction is considered valid (should be by the time we submit it). We can\noptionally defined an upper validity bound using `.validTo` as a TTL\n(Time-To-Live).\n\nLet's make a new file `vesting_unlock.ts` and copy over some of the boilerplate\nfrom the first one.\n\n```ts filename=\"vesting_unlock.ts\"\nimport {\n  Blockfrost,\n  C,\n  Data,\n  Lucid,\n  SpendingValidator,\n  TxHash,\n  fromHex,\n  toHex,\n} from \"https://deno.land/x/lucid@0.8.3/mod.ts\";\nimport * as cbor from \"https://deno.land/x/cbor@v1.4.1/index.js\";\n\nconst lucid = await Lucid.new(\n  new Blockfrost(\n    \"https://cardano-preview.blockfrost.io/api/v0\",\n    Deno.env.get(\"BLOCKFROST_API_KEY\"),\n  ),\n  \"Preview\",\n);","src":"tests/inputs/example--vesting.mdx"},{"chunk":"lucid.selectWalletFromPrivateKey(await Deno.readTextFile(\"./beneficiary.sk\"));\n\nconst beneficiaryPublicKeyHash = lucid.utils.getAddressDetails(\n  await lucid.wallet.address()\n).paymentCredential.hash;\n\nconst validator = await readValidator();\n\n// --- Supporting functions\n\nasync function readValidator(): Promise<SpendingValidator> {\n  const validator = JSON.parse(await Deno.readTextFile(\"plutus.json\")).validators[0];\n  return {\n    type: \"PlutusV2\",\n    script: toHex(cbor.encode(fromHex(validator.compiledCode))),\n  };\n}\n```\n\nNow, let's add the bits to unlock the funds in the contract. We'll need the\ntransaction identifier obtained when you ran the previous script\n(`vesting_lock.ts`)\n\nThat transaction identifier, and the corresponding output index (here, `0`)\nuniquely identifies the UTxO (Unspent Transaction Output) in which the funds\nare currently locked. And that's the one we're about to unlock.\n\nAs we stated above, we need to make sure to only submit our transaction after\nthe vesting delay has passed without what the node will simply reject the\ntransaction (without charging any fee) and kindly ask us to re-submit the\ntransaction at a later time.\n\n```ts filename=\"vesting_unlock.ts\"\n// ^^^ Code above is unchanged. ^^^","src":"tests/inputs/example--vesting.mdx"},{"chunk":"const scriptAddress = lucid.utils.validatorToAddress(validator);\n\n// we get all the UTXOs sitting at the script address\nconst scriptUtxos = await lucid.utxosAt(scriptAddress);\n\nconst Datum = Data.Object({\n  lock_until: Data.BigInt, // this is POSIX time, you can check and set it here: https://www.unixtimestamp.com\n  owner: Data.String, // we can pass owner's verification key hash as byte array but also as a string\n  beneficiary: Data.String, // we can beneficiary's hash as byte array but also as a string\n});\n\ntype Datum = Data.Static<typeof Datum>;\n\nconst currentTime = new Date().getTime();\n\n// we filter out all the UTXOs by beneficiary and lock_until\nconst utxos = scriptUtxos.filter((utxo) => {\n    let datum = Data.from<Datum>(\n      utxo.datum,\n      Datum,\n    );\n\n    return datum.beneficiary === beneficiaryPublicKeyHash &&\n      datum.lock_until <= currentTime;\n});\n\nif (utxos.length === 0) {\n  console.log(\"No redeemable utxo found. You need to wait a little longer...\");\n  Deno.exit(1);\n}\n\n// we don't have any redeemer in our contract but it needs to be empty\nconst redeemer = Data.empty();","src":"tests/inputs/example--vesting.mdx"},{"chunk":"const txUnlock = await unlock(utxos, currentTime, { from: validator, using: redeemer });\n\nawait lucid.awaitTx(txUnlock);\n\nconsole.log(`1 tADA recovered from the contract\n    Tx ID: ${txUnlock}\n    Redeemer: ${redeemer}\n`);\n\n// --- Supporting functions\n\nasync function unlock(utxos, currentTime, { from, using }): Promise<TxHash> {\n  const laterTime = new Date(currentTime + 2 * 60 * 60 * 1000).getTime(); // add two hours (TTL: time to live)\n\n  const tx = await lucid\n    .newTx()\n    .collectFrom(utxos, using)\n    .addSigner(await lucid.wallet.address()) // this should be beneficiary address\n    .validFrom(currentTime)\n    .validTo(laterTime)\n    .attachSpendingValidator(from)\n    .complete();\n\n  const signedTx = await tx\n    .sign()\n    .complete();\n\n  return signedTx.submit();\n}\n```\n\n<Callout>\n  As you imagine, we can run this script with the following incantation:\n\n```\ndeno run --allow-net --allow-read --allow-env vesting_unlock.ts\n```\n\n</Callout>\n\nAssuming everything went well... congratulations ðŸŽ‰!","src":"tests/inputs/example--vesting.mdx"}]